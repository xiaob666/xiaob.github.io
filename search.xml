<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>dockerfile详解</title>
    <url>/CNCF/dockerfile%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>Docker 可以通过 Dockerfile 的内容来自动构建镜像。</p>
<p>Dockerfile 是一个包含创建镜像所有命令的文本文件，通过docker build命令可以根据 Dockerfile 的内容构建镜像，在介绍如何构建之前先介绍下 Dockerfile 的基本语法结构。</p>
<p>Dockerfile 有以下指令选项:</p>
<ul>
<li>FROM</li>
<li>MAINTAINER</li>
<li>RUN</li>
<li>CMD</li>
<li>EXPOSE</li>
<li>ENV</li>
<li>ADD</li>
<li>COPY</li>
<li>ENTRYPOINT</li>
<li>VOLUME</li>
<li>USER</li>
<li>WORKDIR</li>
<li>ONBUILD</li>
</ul>
<h3 id="1-FROM"><a href="#1-FROM" class="headerlink" title="1 FROM"></a><strong>1 FROM</strong></h3><p>用法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>FROM指定构建镜像的基础源镜像，如果本地没有指定的镜像，则会自动从 Docker 的公共库 pull 镜像下来。</li>
<li>FROM必须是 Dockerfile 中非注释行的第一个指令，即一个 Dockerfile 从FROM语句开始。</li>
<li>FROM可以在一个 Dockerfile 中出现多次，如果有需求在一个 Dockerfile 中创建多个镜像。</li>
<li>如果FROM语句没有指定镜像标签，则默认使用latest标签。</li>
</ul>
<h3 id="2-MAINTAINER"><a href="#2-MAINTAINER" class="headerlink" title="2 MAINTAINER"></a><strong>2 MAINTAINER</strong></h3><p>用法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAINTAINER &lt;name&gt;</span><br></pre></td></tr></table></figure>

<p>指定创建镜像的用户</p>
<p>RUN 有两种使用方式</p>
<ul>
<li>RUN</li>
<li>RUN [“executable”, “param1”, “param2”](<a href="http://opskumu.github.io/exec">http://opskumu.github.io/exec</a> form)</li>
</ul>
<p>每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像，后续的RUN都在之前RUN提交后的镜像为基础，镜像是分层的，可以通过一个镜像的任何一个历史提交点来创建，类似源码的 <a href="http://lib.csdn.net/base/git">版本控制</a> 。</p>
<p>exec 方式会被解析为一个 JSON 数组，所以必须使用双引号而不是单引号。exec 方式不会调用一个命令 shell，所以也就不会继承相应的变量，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN [ &quot;echo&quot;, &quot;$HOME&quot; ]</span><br></pre></td></tr></table></figure>

<p>这种方式是不会达到输出 HOME 变量的，正确的方式应该是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo&quot;, &quot;$HOME&quot; ]</span><br></pre></td></tr></table></figure>

<p>RUN产生的缓存在下一次构建的时候是不会失效的，会被重用，可以使用–no-cache选项，即docker build –no-cache，如此便不会缓存。</p>
<h3 id="3-CMD"><a href="#3-CMD" class="headerlink" title="3 CMD"></a><strong>3 CMD</strong></h3><p>CMD有三种使用方式:</p>
<ul>
<li>CMD [“executable”,”param1”,”param2”](<a href="http://opskumu.github.io/exec">http://opskumu.github.io/exec</a> form, this is the preferred form, 优先选择)</li>
<li>CMD [“param1”,”param2”](<a href="http://opskumu.github.io/as">http://opskumu.github.io/as</a> default parameters to <code>ENTRYPOINT</code>)</li>
<li>CMD command param1 param2 (shell form)</li>
</ul>
<p>CMD指定在 Dockerfile 中只能使用一次，如果有多个，则只有最后一个会生效。</p>
<p>CMD的目的是为了在启动容器时提供一个默认的命令执行选项。如果用户启动容器时指定了运行的命令，则会覆盖掉CMD指定的命令。</p>
<blockquote>
<p>CMD会在启动容器的时候执行，build 时不执行，而RUN只是在构建镜像的时候执行，后续镜像构建完成之后，启动容器就与RUN无关了，这个初学者容易弄混这个概念，这里简单注解一下。</p>
</blockquote>
<h3 id="4-EXPOSE"><a href="#4-EXPOSE" class="headerlink" title="4 EXPOSE"></a><strong>4 EXPOSE</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br></pre></td></tr></table></figure>

<p>告诉 Docker 服务端容器对外映射的本地端口，需要在 docker run 的时候使用-p或者-P选项生效。</p>
<h3 id="5-ENV"><a href="#5-ENV" class="headerlink" title="5 ENV"></a><strong>5 ENV</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;       # 只能设置一个变量</span><br><span class="line">ENV &lt;key&gt;=&lt;value&gt; ...   # 允许一次设置多个变量</span><br></pre></td></tr></table></figure>

<p>指定一个环节变量，会被后续RUN指令使用，并在容器运行时保留。</p>
<p>例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENV myName=&quot;John Doe&quot; myDog=Rex\ The\ Dog \</span><br><span class="line">    myCat=fluffy</span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENV myName John Doe</span><br><span class="line">ENV myDog Rex The Dog</span><br><span class="line">ENV myCat fluffy</span><br></pre></td></tr></table></figure>

<h3 id="6-ADD"><a href="#6-ADD" class="headerlink" title="6 ADD"></a><strong>6 ADD</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD &lt;src&gt;... &lt;dest&gt;</span><br></pre></td></tr></table></figure>

<p>ADD复制本地主机文件、目录或者远程文件 URLS 从 并且添加到容器指定路径中 。</p>
<p>支持通过 <a href="http://lib.csdn.net/base/go">Go</a> 的正则模糊匹配，具体规则可参见 <a href="http://golang.org/pkg/path/filepath/#Match">Go filepath.Match</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD hom* /mydir/        # adds all files starting with &quot;hom&quot;</span><br><span class="line">ADD hom?.txt /mydir/    # ? is replaced with any single character</span><br></pre></td></tr></table></figure>

<ul>
<li>路径必须是绝对路径，如果 不存在，会自动创建对应目录</li>
<li>路径必须是 Dockerfile 所在路径的相对路径</li>
<li>如果是一个目录，只会复制目录下的内容，而目录本身则不会被复制</li>
</ul>
<h3 id="7-COPY"><a href="#7-COPY" class="headerlink" title="7 COPY"></a><strong>7 COPY</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COPY &lt;src&gt;... &lt;dest&gt;</span><br></pre></td></tr></table></figure>

<p>COPY复制新文件或者目录从 并且添加到容器指定路径中 。用法同ADD，唯一的不同是不能指定远程文件 URLS。</p>
<p>使用 COPY –chown=root:root 可指定文件目录所属用户</p>
<h3 id="8-ENTRYPOINT"><a href="#8-ENTRYPOINT" class="headerlink" title="8 ENTRYPOINT"></a><strong>8 ENTRYPOINT</strong></h3><ul>
<li>ENTRYPOINT [“executable”, “param1”, “param2”](<a href="http://opskumu.github.io/the">http://opskumu.github.io/the</a> preferred exec form，优先选择)</li>
<li>ENTRYPOINT command param1 param2 (shell form)</li>
</ul>
<p>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖，而CMD是可以被覆盖的。如果需要覆盖，则可以使用docker run –entrypoint选项。</p>
<p>每个 Dockerfile 中只能有一个ENTRYPOINT，当指定多个时，只有最后一个生效。</p>
<h4 id="Exec-form-ENTRYPOINT-例子"><a href="#Exec-form-ENTRYPOINT-例子" class="headerlink" title="Exec form ENTRYPOINT 例子"></a>Exec form ENTRYPOINT 例子</h4><p>通过ENTRYPOINT使用 exec form 方式设置稳定的默认命令和选项，而使用CMD添加默认之外经常被改动的选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]</span><br><span class="line">CMD [&quot;-c&quot;]</span><br></pre></td></tr></table></figure>

<p>通过 Dockerfile 使用ENTRYPOINT展示前台运行 Apache 服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM debian:stable</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y --force-yes apache2</span><br><span class="line">EXPOSE 80 443</span><br><span class="line">VOLUME [&quot;/var/www&quot;, &quot;/var/log/apache2&quot;, &quot;/etc/apache2&quot;]</span><br><span class="line">ENTRYPOINT [&quot;/usr/sbin/apache2ctl&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;]</span><br></pre></td></tr></table></figure>

<h4 id="Shell-form-ENTRYPOINT-例子"><a href="#Shell-form-ENTRYPOINT-例子" class="headerlink" title="Shell form ENTRYPOINT 例子"></a>Shell form ENTRYPOINT 例子</h4><p>这种方式会在/bin/sh -c中执行，会忽略任何CMD或者docker run命令行选项，为了确保docker stop能够停止长时间运行ENTRYPOINT的容器，确保执行的时候使用exec选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT exec top -b</span><br></pre></td></tr></table></figure>

<p>如果在ENTRYPOINT忘记使用exec选项，则可以使用CMD补上:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT top -b</span><br><span class="line">CMD --ignored-param1 # --ignored-param2 ... --ignored-param3 ... 依此类推</span><br></pre></td></tr></table></figure>

<h3 id="9-VOLUME"><a href="#9-VOLUME" class="headerlink" title="9 VOLUME"></a><strong>9 VOLUME</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VOLUME [&quot;/data&quot;]</span><br></pre></td></tr></table></figure>

<p>创建一个可以从本地主机或其他容器挂载的挂载点，后续具体介绍。</p>
<h3 id="10-USER"><a href="#10-USER" class="headerlink" title="10 USER"></a><strong>10 USER</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USER daemon</span><br></pre></td></tr></table></figure>

<p>指定运行容器时的用户名或 UID，后续的RUN、CMD、ENTRYPOINT也会使用指定用户。</p>
<h3 id="11-WORKDIR"><a href="#11-WORKDIR" class="headerlink" title="11 WORKDIR"></a><strong>11 WORKDIR</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WORKDIR /path/to/workdir</span><br></pre></td></tr></table></figure>

<p>为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure>

<p>最终路径是/a/b/c。</p>
<p>WORKDIR指令可以在ENV设置变量之后调用环境变量:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENV DIRPATH /path</span><br><span class="line">WORKDIR $DIRPATH/$DIRNAME</span><br></pre></td></tr></table></figure>

<p>最终路径则为 /path/$DIRNAME。</p>
<h3 id="12-ONBUILD"><a href="#12-ONBUILD" class="headerlink" title="12 ONBUILD"></a><strong>12 ONBUILD</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ONBUILD [INSTRUCTION]</span><br></pre></td></tr></table></figure>

<p>配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。</p>
<p>例如，Dockerfile 使用如下的内容创建了镜像 image-A：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[...]</span><br><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<p>如果基于 image-A 创建新的镜像时，新的 Dockerfile 中使用 FROM image-A 指定基础镜像时，会自动执行 ONBUILD 指令内容，等价于在后面添加了两条指令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Automatically run the following</span><br><span class="line">ADD . /app/src</span><br><span class="line">RUN /usr/local/bin/python-build --dir /app/src</span><br></pre></td></tr></table></figure>

<p>使用ONBUILD指令的镜像，推荐在标签中注明，例如 ruby:1.9-onbuild。</p>
<h3 id="13-Dockerfile-Examples"><a href="#13-Dockerfile-Examples" class="headerlink" title="13 Dockerfile Examples"></a><strong>13 Dockerfile Examples</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Nginx</span><br><span class="line">#</span><br><span class="line"># VERSION               0.0.1</span><br><span class="line">FROM      ubuntu</span><br><span class="line">MAINTAINER Victor Vieux &lt;victor@docker.com&gt;</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y inotify-tools nginx apache2 openssh-server</span><br><span class="line"># Firefox over VNC</span><br><span class="line">#</span><br><span class="line"># VERSION               0.3</span><br><span class="line">FROM ubuntu</span><br><span class="line"># Install vnc, xvfb in order to create a &#x27;fake&#x27; display and firefox</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y x11vnc xvfb firefox</span><br><span class="line">RUN mkdir ~/.vnc</span><br><span class="line"># Setup a password</span><br><span class="line">RUN x11vnc -storepasswd 1234 ~/.vnc/passwd</span><br><span class="line"># Autostart firefox (might not be the best way, but it does the trick)</span><br><span class="line">RUN bash -c &#x27;echo &quot;firefox&quot; &gt;&gt; /.bashrc&#x27;</span><br><span class="line">EXPOSE 5900</span><br><span class="line">CMD    [&quot;x11vnc&quot;, &quot;-forever&quot;, &quot;-usepw&quot;, &quot;-create&quot;]</span><br><span class="line"># Multiple images example</span><br><span class="line">#</span><br><span class="line"># VERSION               0.1</span><br><span class="line">FROM ubuntu</span><br><span class="line">RUN echo foo &gt; bar</span><br><span class="line"># Will output something like ===&gt; 907ad6c2736f</span><br><span class="line">FROM ubuntu</span><br><span class="line">RUN echo moo &gt; oink</span><br><span class="line"># Will output something like ===&gt; 695d7793cbe4</span><br><span class="line"># You᾿ll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with</span><br><span class="line"># /oink.</span><br></pre></td></tr></table></figure>

<h3 id="14-docker-build"><a href="#14-docker-build" class="headerlink" title="14 docker build"></a><strong>14 docker build</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker build --help</span><br><span class="line">Usage: docker build [OPTIONS] PATH | URL | -</span><br><span class="line">Build a new image from the source code at PATH</span><br><span class="line">  --force-rm=false     Always remove intermediate containers, even after unsuccessful builds # 移除过渡容器，即使构建失败</span><br><span class="line">  --no-cache=false     Do not use cache when building the image                              # 不实用 cache        </span><br><span class="line">  -q, --quiet=false    Suppress the verbose output generated by the containers               </span><br><span class="line">  --rm=true            Remove intermediate containers after a successful build               # 构建成功后移除过渡层容器</span><br><span class="line">  -t, --tag=&quot;&quot;         Repository name (and optionally a tag) to be applied to the resulting image in case of success</span><br></pre></td></tr></table></figure>

<p>参考文档: <a href="https://docs.docker.com/reference/builder/">Dockerfile Reference</a></p>
<h3 id="15-dockerfile-最佳实践"><a href="#15-dockerfile-最佳实践" class="headerlink" title="15 dockerfile 最佳实践"></a><strong>15 dockerfile 最佳实践</strong></h3><ul>
<li>使用.dockerignore文件</li>
</ul>
<p>为了在docker build过程中更快上传和更加高效，应该使用一个.dockerignore文件用来排除构建镜像时不需要的文件或目录。例如,除非. <a href="http://lib.csdn.net/base/git">Git</a> 在构建过程中需要用到，否则你应该将它添加到.dockerignore文件中，这样可以节省很多时间。</p>
<ul>
<li>避免安装不必要的软件包</li>
</ul>
<p>为了降低复杂性、依赖性、文件大小以及构建时间，应该避免安装额外的或不必要的包。例如，不需要在一个 <a href="http://lib.csdn.net/base/mysql">数据库</a> 镜像中安装一个文本编辑器。</p>
<ul>
<li>每个容器都跑一个进程</li>
</ul>
<p>在大多数情况下，一个容器应该只单独跑一个程序。解耦应用到多个容器使其更容易横向扩展和重用。如果一个服务依赖另外一个服务，可以参考 <a href="https://docs.docker.com/userguide/dockerlinks/">Linking Containers Together</a> 。</p>
<ul>
<li>最小化层</li>
</ul>
<p>我们知道每执行一个指令，都会有一次镜像的提交，镜像是分层的结构，对于Dockerfile，应该找到可读性和最小化层之间的平衡。</p>
<ul>
<li>多行参数排序</li>
</ul>
<p>如果可能，通过字母顺序来排序，这样可以避免安装包的重复并且更容易更新列表，另外可读性也会更强，添加一个空行使用\换行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">  bzr \</span><br><span class="line">  cvs \</span><br><span class="line">  git \</span><br><span class="line">  mercurial \</span><br><span class="line">  subversion</span><br></pre></td></tr></table></figure>

<ul>
<li>创建缓存</li>
</ul>
<p>镜像构建过程中会按照Dockerfile的顺序依次执行，每执行一次指令 Docker 会寻找是否有存在的镜像缓存可复用，如果没有则创建新的镜像。如果不想使用缓存，则可以在docker build时添加–no-cache=true选项。</p>
<p>从基础镜像开始就已经在缓存中了，下一个指令会对比所有的子镜像寻找是否执行相同的指令，如果没有则缓存失效。在大多数情况下只对比Dockerfile指令和子镜像就足够了。ADD和COPY指令除外，执行ADD和COPY时存放到镜像的文件也是需要检查的，完成一个文件的校验之后再利用这个校验在缓存中查找，如果检测的文件改变则缓存失效。RUN apt-get -y update命令只检查命令是否匹配，如果匹配就不会再执行更新了。</p>
<blockquote>
<p>为了有效地利用缓存，你需要保持你的 Dockerfile 一致，并且尽量在末尾修改。</p>
</blockquote>
<h4 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h4><ul>
<li>FROM: 只要可能就使用官方镜像库作为基础镜像</li>
<li>RUN: 为保持可读性、方便理解、可维护性，把长或者复杂的RUN语句使用\分隔符分成多行<ul>
<li>不建议RUN apt-get update独立成行，否则如果后续包有更新，那么也不会再执行更新</li>
<li>避免使用RUN apt-get upgrade或者dist-upgrade，很多必要的包在一个非privileged权限的容器里是无法升级的。如果知道某个包更新，使用apt-get install -y xxx</li>
<li>标准写法<ul>
<li>RUN apt-get update &amp;&amp; apt-get install -y package-bar package-foo</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">    aufs-tools \</span><br><span class="line">    automake \</span><br><span class="line">    btrfs-tools \</span><br><span class="line">    build-essential \</span><br><span class="line">    curl \</span><br><span class="line">    dpkg-sig \</span><br><span class="line">    git \</span><br><span class="line">    iptables \</span><br><span class="line">    libapparmor-dev \</span><br><span class="line">    libcap-dev \</span><br><span class="line">    libsqlite3-dev \</span><br><span class="line">    lxc=1.0* \</span><br><span class="line">    mercurial \</span><br><span class="line">    parallel \</span><br><span class="line">    reprepro \</span><br><span class="line">    ruby1.9.1 \</span><br><span class="line">    ruby1.9.1-dev \</span><br><span class="line">    s3cmd=1.1.0*</span><br></pre></td></tr></table></figure>

<ul>
<li>CMD: 推荐使用CMD [“executable”, “param1”, “param2”…]这种格式，CMD [“param”, “param”]则配合ENTRYPOINT使用</li>
<li>EXPOSE: Dockerfile 指定要公开的端口，使用docker run时指定映射到宿主机的端口即可</li>
<li>ENV: 为了使新的软件更容易运行，可以使用ENV更新PATH变量。如ENV PATH /usr/local/nginx/bin:$PATH确保CMD [“nginx”]即可运行</li>
</ul>
<p>ENV也可以这样定义变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENV PG_MAJOR 9.3</span><br><span class="line">ENV PG_VERSION 9.3.4</span><br><span class="line">RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</span><br><span class="line">ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</span><br></pre></td></tr></table></figure>

<ul>
<li>ADDorCOPY:ADD比COPY多一些特性「tar 文件自动解包和支持远程 URL」，不推荐添加远程 URL</li>
</ul>
<p>如不推荐这种方式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD http://example.com/big.tar.xz /usr/src/things/</span><br><span class="line">RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span><br><span class="line">RUN make -C /usr/src/things all</span><br></pre></td></tr></table></figure>

<p>推荐使用 curl 或者 wget 替换，使用如下方式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN mkdir -p /usr/src/things \</span><br><span class="line">    &amp;&amp; curl -SL http://example.com/big.tar.gz \</span><br><span class="line">    | tar -xJC /usr/src/things \</span><br><span class="line">    &amp;&amp; make -C /usr/src/things all</span><br></pre></td></tr></table></figure>

<p>如果不需要添加 tar 文件，推荐使用COPY。</p>
]]></content>
      <categories>
        <category>CNCF</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>网络诊断工具</title>
    <url>/Linux/%E7%BD%91%E7%BB%9C%E8%AF%8A%E6%96%AD/</url>
    <content><![CDATA[<h2 id="网络链路测试工具-Linux系统"><a href="#网络链路测试工具-Linux系统" class="headerlink" title="网络链路测试工具 - Linux系统"></a><strong>网络链路测试工具 - Linux系统</strong></h2><h3 id="MTR"><a href="#MTR" class="headerlink" title="MTR"></a>MTR</h3><p>简介：</p>
<p>mtr（My traceroute）几乎是所有Linux发行版本预装的网络测试工具。其将 ping 和 <a href="http://traceroute.sourceforge.net/">traceroute</a> 的功能合并，所以功能更强大。mtr默认发送ICMP数据包进行链路探测。您也可以通过“-u”参数来指定使用UDP数据包进行探测。相对于traceroute只会做一次链路跟踪测试，mtr会对链路上的相关节点做持续探测并给出相应的统计信息。所以，mtr能避免节点波动对测试结果的影响，所以其测试结果更正确，建议优先使用。</p>
<p>相关帮助文档：</p>
<p><a href="http://www.bitwizard.nl/mtr/">http://www.bitwizard.nl/mtr/</a></p>
<p><a href="https://help.aliyun.com/knowledge_detail/98706.html">https://help.aliyun.com/knowledge_detail/98706.html</a></p>
<h3 id="拓展知识点：Traceroute"><a href="#拓展知识点：Traceroute" class="headerlink" title="拓展知识点：Traceroute"></a>拓展知识点：Traceroute</h3><p>traceroute 网络测试工具，用于跟踪Internet协议（IP）数据包传送到目标地址时经过的路径。traceroute先发送小的具有最大存活时间值（Max_TTL）的UDP探测数据包，然后侦听从网关开始的整个链路上的ICMP TIME_EXCEEDED响应。探测从TTL=1开始，TTL值逐步增加，直至接收到ICMP PORT_UNREACHABLE消息。ICMP PORT_UNREACHABLE消息用于标识目标主机已经被定位，或命令已经达到允许跟踪的最大TTL值。traceroute默认发送UDP数据包进行链路探测。可以通过“-I”参数来指定使用ICMP数据包进行探测。</p>
<p>作用：可以定位从源主机到目标主机之间经过了哪些路由器，以及到达各个路由器的耗时。</p>
<p>相关帮助文档：</p>
<p><a href="http://traceroute.sourceforge.net/">http://traceroute.sourceforge.net/</a></p>
<p><a href="https://linux.die.net/man/8/traceroute">https://linux.die.net/man/8/traceroute</a></p>
<h2 id="UDP-PPS测试-和-TCP带宽测试"><a href="#UDP-PPS测试-和-TCP带宽测试" class="headerlink" title="UDP PPS测试 和 TCP带宽测试"></a><strong>UDP PPS测试 和</strong> <strong>TCP带宽测试</strong></h2><h3 id="iperf3"><a href="#iperf3" class="headerlink" title="iperf3"></a>iperf3</h3><p>简介：</p>
<p>iPerf3 是一种用于主动测量 IP 网络上可实现的最大带宽的工具。它支持调整与时序、缓冲区和协议（TCP、UDP、带有 IPv4 和 IPv6 的 SCTP）相关的各种参数。对于每次测试，它都会报告带宽、损耗和其他参数。</p>
<p>这是一个新的实现，它不与原始 iPerf 共享代码，也不向后兼容。iPerf 最初是由NLANR/DAST开发的。iPerf3 主要由ESnet /劳伦斯伯克利国家实验室 开发。</p>
<p>相关帮助文档：</p>
<p><a href="https://iperf.fr/">https://iperf.fr/</a></p>
<p><a href="http://software.es.net/iperf/index.html">http://software.es.net/iperf/index.html</a></p>
<h3 id="Netperf"><a href="#Netperf" class="headerlink" title="Netperf"></a>Netperf</h3><p>简介：</p>
<p>Netperf是一种网络性能的测量工具，主要针对基于<a href="https://baike.baidu.com/item/TCP/33012">TCP</a>或<a href="https://baike.baidu.com/item/UDP/571511">UDP</a>的传输。Netperf根据应用的不同，可以进行不同模式的网络性能测试，即批量数据传输（bulk data transfer）模式和请求/应答（request/reponse）模式。Netperf测试结果所反映的是一个系统能够以多快的速度向另外一个系统发送数据，以及另外一个系统能够以多快的速度接收数据。</p>
<p>相关帮助文档：</p>
<p><a href="https://help.aliyun.com/knowledge_detail/55757.html?spm=5176.21213303.J_6704733920.7.4b0f3edavkBkZV&scm=20140722.S_help@@%E7%9F%A5%E8%AF%86%E7%82%B9@@55757.S_hot+os0.ID_55757-RL_pps%E6%B5%8B%E8%AF%95-OR_helpmain-V_2-P0_0">网络性能测试</a></p>
<p>扩展知识点：</p>
<p>Pktgen：<a href="https://help.aliyun.com/document_detail/260258.htm?spm=a2c4g.11186623.0.0.36005aa38gqGrL">https://help.aliyun.com/document_detail/260258.htm?spm=a2c4g.11186623.0.0.36005aa38gqGrL</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernete常用指标详解</title>
    <url>/CNCF/kubernete%E5%B8%B8%E7%94%A8%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<h4 id="1、资源"><a href="#1、资源" class="headerlink" title="1、资源"></a>1、资源</h4><p>1.1 CPUThrottlingHigh</p>
<p>关于 CPU 的 limit 合理性指标。查出最近5分钟，超过25%的 CPU 执行周期受到限制的容器。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(increase(container_cpu_cfs_throttled_periods_total&#123;container!=&quot;&quot;, &#125;[5m])) by (container, pod, namespace) / sum(increase(container_cpu_cfs_periods_total&#123;&#125;[5m])) by (container, pod, namespace) &gt; ( 25 / 100 )</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>container_cpu_cfs_periods_total：容器生命周期中度过的 cpu 周期总数</li>
<li>container_cpu_cfs_throttled_periods_total：容器生命周期中度过的受限的 cpu 周期总数</li>
</ul>
<p>1.2 KubeCPUOvercommit</p>
<p>集群 CPU 过度使用。CPU 已经过度使用无法容忍节点故障，节点资源使用的总量超过节点的 CPU 总量，所以如果有节点故障将影响集群资源运行因为所需资源将无法被分配。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(namespace:kube_pod_container_resource_requests_cpu_cores:sum&#123;&#125;)/sum(kube_node_status_allocatable_cpu_cores)&gt;(count(kube_node_status_allocatable_cpu_cores)-1) / count(kube_node_status_allocatable_cpu_cores)</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>kube_pod_container_resource_requests_cpu_cores：资源 CPU 使用的 cores 数量</li>
<li>kube_node_status_allocatable_cpu_cores：节点 CPU cores 数量</li>
</ul>
<p>1.3 KubeMemoryOvercommit</p>
<p>集群内存过度使用。内存已经过度使用无法容忍节点故障，节点资源使用的总量超过节点的内存总量，所以如果有节点故障将影响集群资源运行因为所需资源将无法被分配。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(namespace:kube_pod_container_resource_requests_memory_bytes:sum&#123;&#125;)/sum(kube_node_status_allocatable_memory_bytes)&gt;(count(kube_node_status_allocatable_memory_bytes)-1)/count(kube_node_status_allocatable_memory_bytes)</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>kube_pod_container_resource_requests_memory_bytes：资源内存使用的量</li>
<li>kube_node_status_allocatable_memory_bytes：节点内存量</li>
</ul>
<p>1.4 KubeCPUQuotaOvercommit</p>
<p>集群CPU是否超分。查看 CPU 资源分配的额度是否超过进群总额度</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(kube_pod_container_resource_limits_cpu_cores&#123;job=&quot;kube-state-metrics&quot;&#125;)/sum(kube_node_status_allocatable_cpu_cores)&gt; 1.1</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>kube_pod_container_resource_limits_cpu_cores：资源分配的 CPU 资源额度</li>
<li>kube_node_status_allocatable_cpu_cores：节点 CPU 总量</li>
</ul>
<p>1.5 KubeMemoryQuotaOvercommit</p>
<p>集群超分内存，查看内存资源分配的额度是否超过进群总额度</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(kube_pod_container_resource_limits_memory_bytes&#123;job=&quot;kube-state-metrics&quot;&#125;)/sum(kube_node_status_allocatable_memory_bytes&#123;job=&quot;kube-state-metrics&quot;&#125;)&gt; 1.1</span><br></pre></td></tr></table></figure>

<p>相关指标:</p>
<ul>
<li>kube_pod_container_resource_limits_memory_bytes：资源配额内存量</li>
<li>kube_node_status_allocatable_memory_bytes：节点内存量</li>
</ul>
<p>1.6 KubeMEMQuotaExceeded</p>
<p>命名空间级内存资源使用的比例，关乎资源配额。当使用 request 和 limit 限制资源时，使用值和最大值还是有一点区别，当有 request 时说明最低分配了这么多资源。需要注意当 request 等于 limit 时那么说明资源已经是100%已经分配使用当监控告警发出的时候需要区分。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum (kube_pod_container_resource_requests_memory_bytes&#123;job=&quot;kube-state-metrics&quot;&#125; ) by (namespace)/ (sum(kube_pod_container_resource_limits_memory_bytes&#123;job=&quot;kube-state-metrics&quot;&#125;) by (namespace)) &gt; 0.8</span><br></pre></td></tr></table></figure>

<p>相关指标:</p>
<ul>
<li>kube_pod_container_resource_requests_memory_bytes：内存资源使用量</li>
<li>kube_pod_container_resource_limits_memory_bytes：内存资源最大值</li>
</ul>
<p>1.7 KubeCPUQuotaExceeded</p>
<p>命名空间级 CPU 资源使用的比例，关乎资源配额。当使用 request 和 limit 限制资源时，使用值和最大值还是有一点区别，当有 request 时说明最低分配了这么多资源。需要注意当 request 等于 limit 时那么说明资源已经是100%已经分配使用当监控告警发出的时候需要区分。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum (kube_pod_container_resource_requests_cpu_cores&#123;job=&quot;kube-state-metrics&quot;&#125; ) by (namespace)/ (sum(kube_pod_container_resource_limits_cpu_cores&#123;job=&quot;kube-state-metrics&quot;&#125;) by (namespace)) &gt; 0.8</span><br></pre></td></tr></table></figure>

<p>相关指标:</p>
<ul>
<li>kube_pod_container_resource_requests_cpu_cores：CPU 使用量</li>
<li>kube_pod_container_resource_limits_cpu_cores：CPU 限额最大值</li>
</ul>
<h4 id="2、存储"><a href="#2、存储" class="headerlink" title="2、存储"></a>2、存储</h4><p>2.1 KubePersistentVolumeFillingUp</p>
<p>PVC 容量监控</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubelet_volume_stats_available_bytes&#123;job=&quot;kubelet&quot;, metrics_path=&quot;/metrics&quot;&#125;/kubelet_volume_stats_capacity_bytes&#123;job=&quot;kubelet&quot;, metrics_path=&quot;/metrics&quot;&#125;&lt; 0.3</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>kubelet_volume_stats_available_bytes：剩余空间</li>
<li>kubelet_volume_stats_capacity_bytes：空间总量</li>
</ul>
<p>2.2 KubePersistentVolumeFillingUp</p>
<p>磁盘空间耗尽预测：通过PVC资源使用6小时变化率预测 接下来4天的磁盘使用率</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(kubelet_volume_stats_available_bytes&#123;job=&quot;kubelet&quot;, metrics_path=&quot;/metrics&quot;&#125;/kubelet_volume_stats_capacity_bytes&#123;job=&quot;kubelet&quot;, metrics_path=&quot;/metrics&quot;&#125;) &lt; 0.4andpredict_linear(kubelet_volume_stats_available_bytes&#123;job=&quot;kubelet&quot;, metrics_path=&quot;/metrics&quot;&#125;[6h], 4 * 24 * 3600) &lt; 0</span><br></pre></td></tr></table></figure>

<p>相关指标:</p>
<ul>
<li>kubelet_volume_stats_available_bytes：剩余空间</li>
<li>kubelet_volume_stats_capacity_bytes：空间总量</li>
</ul>
<p>2.3 KubePersistentVolumeErrors</p>
<p>PV 使用状态监控。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kube_persistentvolume_status_phase&#123;phase=~&quot;Failed|Pending&quot;,job=&quot;kube-state-metrics&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>kube_persistentvolume_status_phase：PV 使用状态</li>
</ul>
<h4 id="3-kubernetes-system-相关"><a href="#3-kubernetes-system-相关" class="headerlink" title="3. kubernetes system 相关"></a>3. kubernetes system 相关</h4><p>3.1 KubeVersionMismatch</p>
<p>组件版本与当前集群版本是否有差异。对比组件版本是否有差异，默认为1 。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">count(count by (gitVersion) (label_replace(kubernetes_build_info&#123;job!~&quot;kube-dns|coredns&quot;&#125;,&quot;gitVersion&quot;,&quot;$1&quot;,&quot;gitVersion&quot;,&quot;(v[0-9]*.[0-9]*.[0-9]*).*&quot;)))</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>kubernetes_build_info：获取组件信息</li>
</ul>
<p>3.2 KubeClientErrors</p>
<p>客户端访问某些接口的错误率。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(sum(rate(rest_client_requests_total&#123;code=~&quot;5..&quot;&#125;[5m])) by (instance, job)/sum(rate(rest_client_requests_total[5m])) by (instance, job))&gt; 0.01</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>rest_client_requests_total：状态码</li>
</ul>
<h4 id="4-APIServer-相关"><a href="#4-APIServer-相关" class="headerlink" title="4. APIServer 相关"></a>4. APIServer 相关</h4><p>4.1 KubeAPIErrorsHigh</p>
<p>APIServer 请求错误率。5分钟内 APIServer 请求错误率。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(rate(apiserver_request_total&#123;job=&quot;apiserver&quot;,code=~&quot;5..&quot;&#125;[5m])) by (resource,subresource,verb)/sum(rate(apiserver_request_total&#123;job=&quot;apiserver&quot;&#125;[5m])) by (resource,subresource,verb) &gt; 0.05</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>apiserver_request_total：APIServer 请求数</li>
</ul>
<p>4.2 KubeClientCertificateExpiration</p>
<p>kubelet 客户端证书过期。监测证书状态7天告警。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiserver_client_certificate_expiration_seconds_count&#123;job=&quot;apiserver&quot;&#125; &gt; 0 and on(job) histogram_quantile(0.01, sum by (job, le) (rate(apiserver_client_certificate_expiration_seconds_bucket&#123;job=&quot;apiserver&quot;&#125;[5m]))) &lt; 604800</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>apiserver_client_certificate_expiration_seconds_count：证书有效剩余时间</li>
</ul>
<p>4.3 AggregatedAPIErrors</p>
<p>自定义注册的 APIServer 服务可用性监控，当检测到自定义注册的 APIServer 五分钟不用次数达到2次。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum by(name, namespace)(increase(aggregator_unavailable_apiservice_count[5m])) &gt; 2</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>aggregator_unavailable_apiservice_count：监测自定义注册的 APIService 不可用次数。</li>
</ul>
<p>4.4 KubeAPIDown</p>
<p>APIserver 失联，监控 APIServer 服务，失联原因可能是服务 down 还可能是网络出现状况。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">absent(up&#123;job=&quot;apiserver&quot;&#125; == 1)</span><br></pre></td></tr></table></figure>

<h4 id="5-kubelet-相关"><a href="#5-kubelet-相关" class="headerlink" title="5. kubelet 相关"></a>5. kubelet 相关</h4><p>5.1 KubeNodeNotReady</p>
<p>节点是否处于就绪状态。检测节点是否为就绪状态，或者可能是 kubelet 服务down 了。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kube_node_status_condition&#123;job=&quot;kube-state-metrics&quot;,condition=&quot;Ready&quot;,status=&quot;true&quot;&#125; == 0</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>kube_node_status_condition：节点状态监测</li>
</ul>
<p>5.2 KubeNodeUnreachable</p>
<p>节点状态为 Unreachable。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kube_node_spec_unschedulable&#123;job=&quot;kube-state-metrics&quot;&#125; == 1</span><br></pre></td></tr></table></figure>

<p>5.3 KubeletTooManyPods</p>
<p>节点运行过多的 Pod，监测节点上运行的 Pods 数量。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">max(max(kubelet_running_pod_count&#123;job=&quot;kubelet&quot;, metrics_path=&quot;/metrics&quot;&#125;) by(instance) * on(instance) group_left(node) kubelet_node_name&#123;job=&quot;kubelet&quot;, metrics_path=&quot;/metrics&quot;&#125;) by(node) / max(kube_node_status_capacity_pods&#123;job=&quot;kube-state-metrics&quot;&#125; != 1) by(node) &gt; 0.95</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>kubelet_running_pod_count：节点运行的 Pods 数量</li>
<li>kubelet_node_name：节点名称</li>
<li>kube_node_status_capacity_pods：节点可运行的最大 Pod 数量</li>
</ul>
<p>5.4 KubeNodeReadinessFlapping</p>
<p>监测集群状态，查看集群内节点状态改变的频率。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(changes(kube_node_status_condition&#123;status=&quot;true&quot;,condition=&quot;Ready&quot;&#125;[15m])) by (node) &gt; 2</span><br></pre></td></tr></table></figure>

<p>5.5 KubeletDown</p>
<p>监控 kubelet 服务，down 或者网络出现问题。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">absent(up&#123;job=&quot;kubelet&quot;, metrics_path=&quot;/metrics&quot;&#125; == 1)</span><br></pre></td></tr></table></figure>

<h4 id="6-集群组件"><a href="#6-集群组件" class="headerlink" title="6. 集群组件"></a>6. 集群组件</h4><p>6.1 KubeSchedulerDown</p>
<p>KubeScheduler 失联，监测 KubeScheduler 是否正常。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">absent(up&#123;job=&quot;kube-scheduler&quot;&#125; == 1)</span><br></pre></td></tr></table></figure>

<p>6.2 KubeControllerManagerDown</p>
<p>监测 KubeControllerManager 服务，Down 或者网络不通。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">absent(up&#123;job=&quot;kube-controller-manager&quot;&#125; == 1)</span><br></pre></td></tr></table></figure>

<h4 id="7-应用相关"><a href="#7-应用相关" class="headerlink" title="7. 应用相关"></a>7. 应用相关</h4><p>7.1 KubePodCrashLooping</p>
<p>Pod 重启时间，重启时间超过3m告警。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rate(kube_pod_container_status_restarts_total&#123;job=&quot;kube-state-metrics&quot;&#125;[5m]) * 60 * 3 &gt; 0</span><br></pre></td></tr></table></figure>

<p>相关指标:</p>
<ul>
<li>kube_pod_container_status_restarts_total：重启状态 0 为正常</li>
</ul>
<p>7.2 KubePodNotReady</p>
<p>Pods 没有就绪，检测 Pod 是否就绪。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum by (namespace, pod) (max by(namespace, pod) (kube_pod_status_phase&#123;job=&quot;kube-state-metrics&quot;, phase=~&quot;Pending|Unknown&quot;&#125;) * on(namespace, pod) group_left(owner_kind) max by(namespace, pod, owner_kind) (kube_pod_owner&#123;owner_kind!=&quot;Job&quot;&#125;)) &gt; 0</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>kube_pod_status_phase：Pod 状态</li>
</ul>
<p>7.3 KubeDeploymentGenerationMismatch</p>
<p>Deployment 部署失败，Deployment 生成的资源与定义的资源不匹配。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kube_deployment_status_observed_generation&#123;job=&quot;kube-state-metrics&quot;&#125;!=kube_deployment_metadata_generation&#123;job=&quot;kube-state-metrics&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li><p>kube_deployment_status_observed_generation：Deployment 生成资源数</p>
</li>
<li><p>kube_deployment_metadata_generation：Deployment 定义资源数</p>
</li>
</ul>
<p>7.4 KubeDeploymentReplicasMismatch</p>
<p>查看 Deplyment 副本是否达到预期。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(kube_deployment_spec_replicas&#123;job=&quot;kube-state-metrics&quot;&#125;!=kube_deployment_status_replicas_available&#123;job=&quot;kube-state-metrics&quot;&#125;) and (changes(kube_deployment_status_replicas_updated&#123;job=&quot;kube-state-metrics&quot;&#125;[3m])==0)</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>kube_deployment_spec_replicas           资源定义副本数</li>
<li>kube_deployment_status_replicas_available     正在运行副本数</li>
<li>kube_deployment_status_replicas_updated      更新的副本数</li>
</ul>
<p>7.5 KubeStatefulSetReplicasMismatch</p>
<p>监测 StatefulSet 副本是否达到预期。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(kube_statefulset_status_replicas_ready&#123;job=&quot;kube-state-metrics&quot;&#125;!=kube_statefulset_status_replicas&#123;job=&quot;kube-state-metrics&quot;&#125;) and (changes(kube_statefulset_status_replicas_updated&#123;job=&quot;kube-state-metrics&quot;&#125;[5m])==0)</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>kube_statefulset_status_replicas_ready：就绪副本数</li>
<li>kube_statefulset_status_replicas：当前副本数</li>
<li>kube_statefulset_status_replicas_updated：更新的副本数</li>
</ul>
<p>7.6 KubeStatefulSetUpdateNotRolledOut</p>
<p>StatefulSet  更新失败且未回滚，对比版本号和副本数。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">max without (revision) (kube_statefulset_status_current_revision&#123;job=&quot;kube-state-metrics&quot;&#125;unlesskube_statefulset_status_update_revision&#123;job=&quot;kube-state-metrics&quot;&#125;)*(kube_statefulset_replicas&#123;job=&quot;kube-state-metrics&quot;&#125;!=kube_statefulset_status_replicas_updated&#123;job=&quot;kube-state-metrics&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>kube_statefulset_status_replicas：每个 StatefulSet 的副本数。</li>
<li>kube_statefulset_status_replicas_current：每个 StatefulSet 的当前副本数。</li>
<li>kube_statefulset_status_replicas_ready：每个StatefulSet 的就绪副本数。</li>
<li>kube_statefulset_status_replicas_updated：每个StatefulSet 的更新副本数。</li>
<li>kube_statefulset_status_observed_generation：StatefulSet 控制器观察到的生成。</li>
<li>kube_statefulset_replicas：StatefulSet 所需的副本数。</li>
<li>kube_statefulset_metadata_generation：表示 StatefulSet 所需状态的特定生成的序列号。</li>
<li>kube_statefulset_created：创建时间戳。</li>
<li>kube_statefulset_labels：Kubernetes 标签转换为 Prometheus 标签。</li>
<li>kube_statefulset_status_current_revision：指示用于按顺序(0，currentReplicas)生成 Pod 的StatefulSet 的版本。</li>
<li>kube_statefulset_status_update_revision：指示用于按顺序 [replicas-updatedReplicas，replicas] 生成 Pod 的 StatefulSet 的版本。</li>
</ul>
<p>7.7 KubeDaemonSetRolloutStuck</p>
<p>监测 DaemonSet 是否处于就绪状态。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kube_daemonset_status_number_ready&#123;job=&quot;kube-state-metrics&quot;&#125;/kube_daemonset_status_desired_number_scheduled&#123;job=&quot;kube-state-metrics&quot;&#125; &lt; 1.00</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>kube_daemonset_status_number_ready：就绪的 DaemonSet</li>
<li>kube_daemonset_status_desired_number_scheduled：应该调度的 DaemonSet 数量</li>
</ul>
<p>7.8 KubeDaemonSetMisScheduled</p>
<p>DaemonSet  运行在不该运行的节点上面。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kube_daemonset_status_number_misscheduled&#123;job=&quot;kube-state-metrics&quot;&#125; &gt; 0</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>kube_daemonset_status_number_misscheduled：运行在不该运行的节点状态</li>
</ul>
<p>7.9 KubeContainerWaiting</p>
<p>监测哪些容器是在等待状态的。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum by (namespace, pod, container) (kube_pod_container_status_waiting_reason&#123;job=&quot;kube-state-metrics&quot;&#125;) &gt; 0</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>kube_pod_container_status_waiting_reason：容器声明周期过程中的状态，无论是创建成功还是失败都应该是0。</li>
</ul>
<h2 id="8-节点相关"><a href="#8-节点相关" class="headerlink" title="8. 节点相关"></a>8. 节点相关</h2><p>8.1 NodeClockNotSynchronising</p>
<p>主机与时间服务器失联。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">min_over_time(node_timex_sync_status[5m]) == 0</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>node_timex_sync_status：同步状态。</li>
</ul>
<p>8.2 NodeClockSkewDetected</p>
<p>本地时间偏移量。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(node_timex_offset_seconds &gt; 0.05 and deriv(node_timex_offset_seconds[5m]) &gt;= 0 ) or (node_timex_offset_seconds &lt; -0.05 and deriv(node_timex_offset_seconds[5m]) &lt;= 0)</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>node_timex_offset_seconds：误差</li>
</ul>
<p>8.3 NodeHighNumberConntrackEntriesUsed</p>
<p>链接状态跟踪。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(node_nf_conntrack_entries / node_nf_conntrack_entries_limit) &gt; 0.75</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>node_nf_conntrack_entries：链接状态跟踪表分配的数量</li>
<li>node_nf_conntrack_entries_limit：表总量</li>
</ul>
<p>8.4 NodeNetworkReceiveErrs</p>
<p>网卡接收错误量。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">increase(node_network_receive_errs_total[2m]) &gt; 10</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>node_network_receive_errs_total：接收错误总量</li>
</ul>
<p>8.5 NodeNetworkTransmitErrs</p>
<p>网卡传输错误量。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">increase(node_network_transmit_errs_total[2m]) &gt; 10</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>node_network_transmit_errs_total：传输错误总量</li>
</ul>
<p>8.6 NodeFilesystemAlmostOutOfFiles</p>
<p>inode 数量监测</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(node_filesystem_files_free&#123;job=&quot;node-exporter&quot;,fstype!=&quot;&quot;&#125; / node_filesystem_files&#123;job=&quot;node-exporter&quot;,fstype!=&quot;&quot;&#125; * 100 &lt; 5 and node_filesystem_readonly&#123;job=&quot;node-exporter&quot;,fstype!=&quot;&quot;&#125; == 0)</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>node_filesystem_files_free：空闲的 inode</li>
<li>node_filesystem_files：inodes 总量</li>
</ul>
<p>8.7 NodeFilesystemFilesFillingUp</p>
<p>inode 耗尽预测，以6小时曲线变化预测接下来24小时和4小时可能使用的 inodes。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(node_filesystem_files_free&#123;job=&quot;node-exporter&quot;,fstype!=&quot;&quot;&#125; / node_filesystem_files&#123;job=&quot;node-exporter&quot;,fstype!=&quot;&quot;&#125; * 100 &lt; 20 and predict_linear(node_filesystem_files_free&#123;job=&quot;node-exporter&quot;,fstype!=&quot;&quot;&#125;[6h], 4*60*60) &lt; 0 and node_filesystem_readonly&#123;job=&quot;node-exporter&quot;,fstype!=&quot;&quot;&#125; == 0)</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>node_filesystem_files_free：空闲的 inode</li>
<li>node_filesystem_files：inodes 总量</li>
</ul>
<p>8.8 NodeFilesystemAlmostOutOfSpace</p>
<p>分区容量使用率。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(node_filesystem_avail_bytes&#123;job=&quot;node-exporter&quot;,fstype!=&quot;&quot;&#125; / node_filesystem_size_bytes&#123;job=&quot;node-exporter&quot;,fstype!=&quot;&quot;&#125; * 100 &lt; 10 and node_filesystem_readonly&#123;job=&quot;node-exporter&quot;,fstype!=&quot;&quot;&#125; == 0 )</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>node_filesystem_avail_bytes：空闲容量</li>
<li>node_filesystem_size_bytes：总容量</li>
</ul>
<p>8.9 NodeFilesystemSpaceFillingUp</p>
<p>分区容量耗尽预测，以6小时曲线变化预测接下来24小时和4小时可能使用的容量。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(node_filesystem_avail_bytes&#123;job=&quot;node-exporter&quot;,fstype!=&quot;&quot;&#125; / node_filesystem_size_bytes&#123;job=&quot;node-exporter&quot;,fstype!=&quot;&quot;&#125; * 100 &lt; 15 and predict_linear(node_filesystem_avail_bytes&#123;job=&quot;node-exporter&quot;,fstype!=&quot;&quot;&#125;[6h], 4*60*60) &lt; 0 and node_filesystem_readonly&#123;job=&quot;node-exporter&quot;,fstype!=&quot;&quot;&#125; == 0)</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>node_filesystem_avail_bytes：空闲容量</li>
<li>node_filesystem_size_bytes：总容量</li>
</ul>
<h4 id="9-Etcd-相关"><a href="#9-Etcd-相关" class="headerlink" title="9. Etcd 相关"></a>9. Etcd 相关</h4><p>9.1 Etcdlived</p>
<p>etcd 存活检测。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">up&#123;job=&quot;etcd&quot;&#125; &lt; 1</span><br></pre></td></tr></table></figure>

<p>9.2 EtcdCluseterUnavailable</p>
<p>etcd 集群健康检查，down 数量大于集群可允许故障数量。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">count(up&#123;job=&quot;etcd&quot;&#125; == 0) &gt; (count(up&#123;job=&quot;etcd&quot;&#125;) / 2 - 1)</span><br></pre></td></tr></table></figure>

<p>9.3 EtcdLeaderCheck</p>
<p>检查 leader。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">max(etcd_server_has_leader) != 1</span><br></pre></td></tr></table></figure>

<p>9.4 EtcdBackendFsync</p>
<p>etcd io 监测，后端提交 延时。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">histogram_quantile(0.99, sum(rate(etcd_disk_backend_commit_duration_seconds_bucket[5m])) by (instance, le)) &gt; 100</span><br></pre></td></tr></table></figure>

<p>9.5 EtcdWalFsync</p>
<p>etcd io 监测，文件同步到磁盘延时。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">histogram_quantile(0.99, sum(rate(etcd_disk_wal_fsync_duration_seconds_bucket[5m])) by (instance, le)) &gt; 100</span><br></pre></td></tr></table></figure>

<p>9.6 EtcdDbSize</p>
<p>检测数据库大小。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">etcd_debugging_mvcc_db_total_size_in_bytes/1024/1024 &gt; 1024</span><br></pre></td></tr></table></figure>

<p>9.7 EtcdGrpc</p>
<p>Grpc 调用速率。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(rate(grpc_server_handled_total&#123;grpc_type=&quot;unary&quot;&#125;[1m])) &gt; 100</span><br></pre></td></tr></table></figure>

<h4 id="10-CoreDNS-相关"><a href="#10-CoreDNS-相关" class="headerlink" title="10. CoreDNS 相关"></a>10. CoreDNS 相关</h4><p>10.1 DnsRequest</p>
<p>DNS 查询速率，每分钟查询超过100告警。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(irate(coredns_dns_request_count_total&#123;zone !=&quot;dropped&quot;&#125;[1m])) &gt; 100</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>coredns_dns_request_count_total：总查询数</li>
</ul>
<p>10.2 DnsRequestFaild</p>
<p>异常查询，异常状态码，不是 NOERROR。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">irate(coredns_dns_response_rcode_count_total&#123;rcode!=&quot;NOERROR&quot;&#125; [1m]) &gt; 0</span><br></pre></td></tr></table></figure>

<p>相关指标：</p>
<ul>
<li>coredns_dns_response_rcode_count_total：查询返回状态码</li>
</ul>
<p>DNS-Rcode：</p>
<p>DNS-Rcode 作为 DNS 应答报文中有效的字段，主要用来说明 DNS 应答状态，是排查域名解析失败的重要指标。通常常见的 Rcode 值如下：</p>
<ul>
<li>Rcode 值为0，对应的 DNS 应答状态为 NOERROR，意思是成功的响应，即这个域名解析是成功</li>
<li>Rcode 值为2，对应的 DNS 应答状态为 SERVFAIL，意思是服务器失败，也就是这个域名的权威服务器拒绝响应或者响应 REFUSE，递归服务器返回 Rcode 值为 2 给 CLIENT</li>
<li>Rcode 值为3，对应的 DNS 应答状态为 NXDOMAIN，意思是不存在的记录，也就是这个具体的域名在权威服务器中并不存在</li>
<li>Rcode 值为5，对应的 DNS 应答状态为 REFUSE，意思是拒绝，也就是这个请求源IP不在服务的范围内</li>
</ul>
<p>10.3 DnsPanic</p>
<p>DNS 恐慌值，可能收到攻击。</p>
<p>表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">irate(coredns_panic_count_total[1m]) &gt; 100</span><br></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a href="https://github.com/coreos/kube-prometheus">https://github.com/coreos/kube-prometheus</a></li>
<li><a href="https://github.com/kubernetes-monitoring/kubernetes-mixin">https://github.com/kubernetes-monitoring/kubernetes-mixin</a></li>
<li><a href="https://github.com/google/cadvisor/blob/master/docs/storage/prometheus.md">https://github.com/google/cadvisor/blob/master/docs/storage/prometheus.md</a></li>
</ol>
]]></content>
      <categories>
        <category>CNCF</category>
      </categories>
      <tags>
        <tag>监控</tag>
        <tag>指标</tag>
        <tag>kubernete</tag>
      </tags>
  </entry>
</search>
